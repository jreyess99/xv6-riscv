Informe: Implementación de Prioridades en el Scheduler de xv6

En este trabajo se llevó a cabo una modificación del sistema operativo educativo xv6 para incorporar un sistema de prioridades en el programador de procesos (scheduler). El objetivo de esta modificación fue permitir que los procesos fueran gestionados según su prioridad, con la adición de un sistema de boost que ajusta la prioridad de manera dinámica. En esta implementación, los procesos con una menor prioridad numérica (es decir, con mayor prioridad en el sistema) reciben más tiempo de CPU, mientras que aquellos con una mayor prioridad numérica son ejecutados con menos frecuencia hasta que su prioridad se degrade.

Para llevar a cabo este cambio, se realizaron varias modificaciones en la estructura de procesos (proc) de xv6. Se añadieron dos nuevos campos: priority y boost. El campo priority representa la prioridad del proceso, donde un valor más bajo indica mayor prioridad. Inicialmente, cada proceso comienza con una prioridad de 0. Por otro lado, el campo boost se utiliza para incrementar o decrementar la prioridad de un proceso durante su vida útil. Este valor empieza en 1 y se ajusta dinámicamente según la ejecución del proceso.

La lógica de asignación de prioridad se implementó en el ciclo principal del scheduler. En cada iteración, se ajusta la prioridad de los procesos que están en el estado RUNNABLE, incrementando o decrementando su prioridad según el valor del boost. Si la prioridad alcanza 9 (el valor máximo permitido), el boost se cambia a -1, y si la prioridad llega a 0 (el valor mínimo), el boost se ajusta nuevamente a 1. De esta forma, los procesos con mayor prioridad son ejecutados más frecuentemente, mientras que aquellos con menor prioridad ven reducida su frecuencia de ejecución.

El scheduler también fue modificado para seleccionar el proceso a ejecutar basándose en la prioridad. En cada ciclo, el scheduler elige el proceso con menor valor de priority entre los procesos RUNNABLE. En caso de que varios procesos tengan la misma prioridad, se elige el primero que se encuentra en estado ejecutable.

Además de las modificaciones en el código del scheduler, se desarrolló un programa de prueba llamado prio_test.c, el cual crea 20 procesos utilizando la llamada al sistema fork(). Cada proceso hijo imprime un mensaje indicando su PID y su número de proceso, luego se detiene durante un breve período utilizando la función sleep() para simular la carga de trabajo. Este programa permitió verificar que los procesos con menor prioridad fueran ejecutados con mayor frecuencia, mientras que aquellos con mayor prioridad eran penalizados progresivamente a medida que el sistema ajustaba sus valores de boost y priority.

Durante el desarrollo de la tarea, se enfrentaron algunos desafíos, particularmente en la gestión del boost. Inicialmente, se producía un comportamiento inesperado cuando la prioridad de un proceso sobrepasaba los límites establecidos, lo que resultaba en una incorrecta aplicación del boost. Este problema fue resuelto añadiendo comprobaciones adicionales para asegurar que los ajustes de prioridad siempre se mantuvieran dentro de los valores permitidos. Además, surgió una dificultad relacionada con la longitud de los nombres de archivo en el sistema de archivos de xv6, que impone un límite de 14 caracteres. Esto obligó a renombrar el archivo de prueba de priorities_test.c a prio_test.c.

Las pruebas realizadas con el programa prio_test.c confirmaron que el sistema de prioridades y boost funcionaba correctamente. Se observó que los procesos de mayor prioridad (con menor valor numérico) eran ejecutados más frecuentemente, mientras que los procesos con menor prioridad (mayor valor numérico) eran ejecutados menos frecuentemente, como se esperaba.

En conclusión, la implementación de un sistema de prioridades y boost en el scheduler de xv6 permitió un control más eficiente sobre la asignación de tiempo de CPU entre los procesos. Esta modificación representa un paso adelante en la comprensión y desarrollo de sistemas de programación de procesos más complejos, proporcionando una base sólida para futuras mejoras y estudios en la gestión de procesos en sistemas operativos.

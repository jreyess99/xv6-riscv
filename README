Introducción

Este informe detalla la implementación de un sistema de protección de memoria en el sistema operativo xv6 RISC-V, explicando tanto el funcionamiento de las funcionalidades implementadas como las modificaciones realizadas en el código fuente. Además, se discuten las dificultades encontradas durante el proceso y cómo se resolvieron.

Las funciones implementadas son:

    mprotect: Su función es marcar un rango de memoria como de solo lectura, deshabilitando el bit de escritura en las páginas correspondientes.
    munprotect: Revierte la acción de mprotect, habilitando nuevamente los permisos de escritura en las páginas.

Modificaciones Realizadas

A continuación, se detallan las modificaciones realizadas en el código fuente de xv6 para implementar las funciones de protección de memoria:

    syscall.h:
        Se asignaron números únicos para las nuevas llamadas al sistema sys_mprotect (número 22) y sys_munprotect (número 23).

    syscall.c:
        Se agregaron los prototipos de las funciones correspondientes a las nuevas llamadas al sistema:
        extern uint64 sys_mprotect(void)
        extern uint64 sys_munprotect(void)
        Se incluyeron las nuevas llamadas en el array que mapea los números de las llamadas al sistema con sus respectivas implementaciones:
        [SYS_mprotect] sys_mprotect
        [SYS_munprotect] sys_munprotect

    defs.h:
        Se declararon las funciones mprotect y munprotect para que estén disponibles para el código del núcleo, permitiendo que otras funciones del kernel puedan utilizarlas:
        int mprotect(uint64 addr, int len)
        int munprotect(uint64 addr, int len)

    user.h:
        Se proporcionaron las declaraciones de las funciones mprotect y munprotect para permitir que los programas de usuario puedan invocar estas funciones:
        int mprotect(void *addr, int len)
        int munprotect(void *addr, int len)

    usys.pl:
        Se añadieron las entradas correspondientes para que las funciones mprotect y munprotect sean accesibles desde el espacio de usuario, utilizando las directivas:
        entry("mprotect")
        entry("munprotect")

    vm.c:
        Se incluyeron los encabezados spinlock.h y proc.h necesarios para la implementación de las funciones mprotect y munprotect.
        Se implementaron las funciones mprotect y munprotect, que interactúan con las tablas de páginas para modificar los permisos de memoria.

    sysproc.c:
        Se implementaron las llamadas al sistema sys_mprotect y sys_munprotect, las cuales actúan como intermediarias entre el espacio de usuario y las funciones del núcleo que manejan la protección de memoria.

    test_protect.c:
        Se desarrolló un programa de prueba para verificar el funcionamiento de las nuevas llamadas al sistema.

    Makefile:
        Se modificó el Makefile para asegurar que el programa de prueba sea compilado junto con el resto del sistema.

Problemas Encontrados y Soluciones

Durante la implementación, se presentaron diversos problemas que fueron resueltos de la siguiente manera:

    Definiciones faltantes:
        Inicialmente, las funciones mprotect y munprotect no estaban definidas en los archivos necesarios, lo que provocó errores de compilación. La solución fue agregar las definiciones directamente en el archivo vm.c. Posteriormente, se descubrió que la solución más adecuada era declarar estas funciones en el archivo defs.h, lo cual resolvió el problema de forma satisfactoria.

    Error con el campo ‘lock’:
        Al compilar, se presentó un error en vm.c relacionado con el campo lock, indicando que su tipo estaba incompleto. La solución fue incluir el encabezado spinlock.h en la cabecera del archivo, lo que resolvió el error.

Conclusiones

La implementación de las funciones de protección de memoria mprotect y munprotect en xv6 fue exitosa, permitiendo controlar los permisos de escritura en las páginas de memoria de los procesos. A pesar de los problemas encontrados durante el proceso de desarrollo, las soluciones aplicadas fueron efectivas, lo que resultó en la compilación y ejecución exitosa del sistema. Este trabajo refuerza la comprensión de los mecanismos de gestión de memoria en sistemas operativos y proporciona una base para futuras extensiones en el manejo de memoria en xv6.
